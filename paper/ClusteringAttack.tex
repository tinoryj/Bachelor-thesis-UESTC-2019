\chapter{基于聚类的频率分析攻击方法}
\label{sec:ClusteringAttack}

本章放松了基于分布的频率分析攻击中的攻击者的攻击条件要求，提出了基于聚类的频率分析攻击，它不需要使用明文数据块的细粒度排序信息。相反，它利用相似性这一属性来推断来自相似的数据段（即，由数据块块聚合形成的更大的数据单元）的原始数据块，而不依赖于每个数据段中的数据块的排序。 本章首先介绍相似性的概念，然后展示如何使该属性进行推理攻击。

\section{背景知识}
\label{sec:similarity}

\subsection{min-wise independence条件}

对于min-wise independence置换族有如下定义：设$S_n$是$n$元集合$[n]$上所有置换组成的n元对称群。称置换族$F \subseteq S_n$满足min-wise independence条件是指：对任意$X=\{x_1,x_2,\cdots,x_m\}\in[n]$和任意$x_i-inX$，从集合$F$中随机、均匀地选取函数$h$，计算$H(X)=\{h(x_1),h(x_2),\cdots,h(x_m),\}$，有下式成立：
\begin{equation}
    \label{eq:min-wise independence}
    Pr(min(H(X)) = h(x_i) ) = \frac{1}{|X|}
\end{equation}

即$X$中的所有元素在$h$的作用下都有相等的概率成为$H(X)$中的最小元。在实际应用中，完全满足min-wise independence条件的哈希函数很难实现，通常使用近似满足min-wise independence条件的哈希函数即可。

\subsection{Broder定理}
Broder定理\cite{broder1997resemblance}的定义为：两集合$S_1$和$S_2$，$H(S_i)=\{h(x_k)|\forall x_k \in S_i \}$，h是满足min-wise independence条件的哈希函数，$min(S_i)$代表集合$S_i$中的最小元，则

\begin{equation}
    \label{eq:broder}
    \Pr[\min\{{\rm H}(S_1)\} = \min\{{\rm H}(S_2)\} ] = \frac{|S_1 \cap S_2|}{|S_1 \cup S_2|}
\end{equation}

\subsection{相似性}
相似性\cite{bhagwat2009extreme}指出来自同一来源的备份文件可能类似并且共享大部分相同的数据块。 备份文件之间的相似性可以通过Broder定理\cite{broder1997resemblance}来量化。具体来说，如果将每个文件视为一个数据块的集合$S$（即忽略它们的顺序），Broder定理指出如果两组数据块共享相同的最小数据块哈希值的概率很高，则两个集合包含的数据块可能大部分都相同，反之亦然：
 
\begin{eqnarray}
	\Pr[\min\{{\rm H}(S)\} = \min\{{\rm H}(S')\} ] = \frac{|S \cap S'|}{|S \cup S'|}
	\label{eq:similary}
\end{eqnarray}

其中${\rm H}(\cdot)$是一个从min-wise independence置换族中随机统一选择的哈希函数，$\min\{{\rm H}(S)\}$是$S$的最小数据块的哈希。为了便于描述，本文使用MinHash来表示集合中元素的最小哈希值。


针对重复数据删除的各个方面（性能方面\cite{qin2017design,xia2011silo,bhagwat2009extreme}，安全方面\cite{li2017information}）的已有工作已经利用了相似性这一属性来保持存储效率。具体来说，它们仅针对共享相同最小数据块哈希的文件（即类似的文件）采用MinHash作为一个数据块集合中所有数据块加密使用的密钥进行重复数据删除。根据Broder定理可以推断得到这类文件可能具有大量相同的数据块，因此这种近似精确的重复数据删除只会导致存储效率的轻微降低。与先前的方法不同\cite{qin2017design,xia2011silo,bhagwat2009extreme,li2017information}，本文应用相似性来提高频率分析攻击的有效性。
 
\section{基于聚类的频率分析攻击方法定义}
\label{sec:clustering-attack-description}

现在提出基于聚类的频率分析攻击方法（图：\ref{fig:基于聚类的攻击方法的工作流程}），它基于相似性在加密重复数据删除中推断密文数据块的原始明文数据块。

\begin{figure}[!htb]
    \small
    \centering
    \includegraphics[width=14cm]{ClusteringAttack.eps}
    \caption{基于聚类的攻击方法的工作流程：用MinHash表示明文数据段的最小块散列} 
    \label{fig:基于聚类的攻击方法的工作流程}
\end{figure}

为了利用相似，本文首先在数据块概念的基础上引入数据段的概念。具体来说，将$\mathbf{C}$划分为为一些粗粒度的数据单元，成为密文数据段。密文数据段使用$S_\mathbf{C}$来表示，其中包含有$\mathbf{C}$中的多个相邻的密文数据块。在本课题中，应用了定长分段方法，以确保每个数据段具有相同分的大小（例如，默认大小为4MB）。同样的，对于攻击者所具有的辅助信息$\mathbf{A}$，也同样使用定长分段方法产生多个明文数据段，每个数据段由$S_\mathbf{A}$表示。

注意，一些可变大小的分段方案\cite{lillibridge2009sparse,qin2017design}在其内容与特定模式匹配的数据块之后设置分段边界，从而解决固定大小分段方案所面临的边界移位问题。但是，本文不能在攻击中使用这些可变大小的分段方案\cite{lillibridge2009sparse,qin2017design}。其原因是密文数据段中的数据块的原始内容受到对称加密的保护，攻击者无法确保密文和明文数据段的边界匹配采用的是相同的模式。该问题会导致密文和明文数据段不兼容，从而会降低基于聚类的攻击方法所推断的数据段级的数据量（请参阅本章后半部分）。
 
本章通过类似的数据段来推断密文-明文对。

We propose to infer ciphertext-plaintext pairs through similar segments. Let $S_\mathbf{M}$ be the original plaintext segment of a ciphertext segment $S_\mathbf{C}$ (i.e., each plaintext in $S_\mathbf{M}$ corresponds to some ciphertext in $S_\mathbf{C}$ and vice versa). According to Broder's theorem, if $S_\mathbf{M}$ shares the same minimum chunk hash, say $h$, with some plaintext segment $S_\mathbf{A}$, then $S_\mathbf{M}$  and $S_\mathbf{A}$ tend to have a large fraction of identical plaintexts. This implies that the ciphertexts in $S_\mathbf{C}$ are likely to be mapped from the plaintexts in  $S_\mathbf{A}$. In other words, we first classify all plaintext segments of $\mathbf{A}$ by their minimum chunk hashes, and obtain multiple {\em plaintext clusters}. Each plaintext cluster, denoted by $\mathcal{C}_\mathbf{A} = \{ S_\mathbf{A} \}$, corresponds to a unique minimum chunk hash shared by its included segments. We also group the ciphertext segments, whose original plaintext segments have the same minimum chunk hash $h$ (i.e., similar), into an identical {\em ciphertext cluster}, denoted by $\mathcal{C}_\mathbf{C} = \{ S_\mathbf{C} \}$. Then, we infer the original data of $\mathcal{C}_\mathbf{C}$ from some $\mathcal{C}_\mathbf{A}$ that corresponds to  $h$.    

本文提出了一种聚类方案来对类似的密文数据段进行分组。一种简易的方法是按照最小数据块哈希对段进行分类，但它不适用于原始内容受到对称加密保护的密文数据段。本文基于Broder定理解决分类问题。
  
本文认为，如果两个密文数据段具有大部分相同的密文，那么它们对应于具有高概率的相同的最小块散列。 原因在于确定性加密保留了明文段的并集和交叉的基数，基于此我们可以使用Broder定理来学习它们的最小块散列的等价性。
  
Our insight is that if two ciphertext segments have a large fraction of identical ciphertexts, then  they correspond to the same minimum chunk hash with a high probability. The reason is that deterministic encryption preserves the cardinalities of union and intersection of plaintext segments, based on which we can use Broder's theorem to learn the equivalence of their minimum chunk hashes.    

在本文中，定义任意两个密文数据段$S_\mathbf{C}$和$S_\mathbf{C}'$的聚类距离$d(S_\mathbf{C},S_\mathbf{C}')$为1减去相同密文的分数：

In this work, we define the clustering distance $d(S_\mathbf{C}, S_\mathbf{C}')$ of any two ciphertext segments $S_\mathbf{C}$ and $S_\mathbf{C}'$ by one minus the fraction of their identical ciphertexts:

\begin{eqnarray}
d(S_\mathbf{C}, S_\mathbf{C}') = 1 - \frac{|S_\mathbf{C} \cap S_\mathbf{C}'|}{|S_\mathbf{C} \cup S_\mathbf{C}'|}. \nonumber
\end{eqnarray}

Note that identical ciphertexts may repeat in $S_\mathbf{C}$ or $S_\mathbf{C}'$, and $|S_\mathbf{C} \cap S_\mathbf{C}'|$ and $|S_\mathbf{C} \cup S_\mathbf{C}'|$ return the number of {\em unique} ciphertexts in their  intersection and union, respectively. Clearly,  the smaller $d(S_\mathbf{C}, S_\mathbf{C}')$ is, the more likely are $S_\mathbf{C}$ and $S_\mathbf{C}'$ to correspond to the same minimum chunk hash. Then, we adopt the {\em agglomerative hierarchical clustering (AHC)} \cite{johnson67} to aggregate similar ciphertext segments based on their distance information.  Specifically, we start with eash ciphertext segment in its own singleton cluster, and iteratively combine the two closest clusters based on the maximum distance of their ciphertext segments. We configure a parameter $k$, and stop the iterated combination when the maximum distance of ciphertext segments in the two cloestclusters is greater than $k$.  

For each aggregated ciphertext cluster $\mathcal{C}_\mathbf{C}$, we relate it to some plaintext cluster $\mathcal{C}_\mathbf{A}$ with frequency analysis, while taking frequency distribution into account. This is based on the observation that identical ciphertexts (resp. plaintexts) may  repeat in the same or different ciphertext (resp. plaintext) segments and identical ciphertext (resp. plaintext) segments may also repeat in the same ciphertext (resp. plaintext) cluster. We propose to examine the frequency distribution of the logical ciphertexts or plaintexts in each cluster, and perceive that the frequency distributions for similar clusters (i.e., correspond to the same minimum chunk hash) are also likely to be similar. 
 
We proceed the frequency analysis scheme as follows. First, we  sort available ciphertext and plaintext clusters by the total number of logical  ciphertexts and plaintexts they include, respectively. Then, we count an associative array $\mathbf{F}$ that stores the frequency of each unique ciphertext or plaintext in  corresponding cluster. Based on $\mathbf{F}$, we compute the probability that a  ciphertext $C$ exists in a ciphertext cluster $\mathcal{C}_\mathbf{C}$ and further the entropy of $\mathcal{C}_\mathbf{C}$:        

\begin{eqnarray*}
    \Pr[C \in \mathcal{C}_\mathbf{C}] = \frac{\mathbf{F}[\mathcal{C}_\mathbf{C}][C]}{\sum_{C' \in \mathcal{C}_\mathbf{C}} \mathbf{F}[\mathcal{C}_\mathbf{C}][C']}, \\
    e(\mathcal{C}_\mathbf{C}) = \sum_{C \in \mathcal{C}_\mathbf{C}} \log_2 \frac{1}{\Pr[C \in \mathcal{C}_\mathbf{C}]},  
\end{eqnarray*}

where $\mathbf{F}[\mathcal{C}_\mathbf{C}][C]$  stores the frequency of $C$ in $\mathcal{C}_\mathbf{C}$. Similarly, we  compute the entropy $e(\mathcal{C}_\mathbf{A})$ for the plaintext cluster $\mathcal{C}_\mathbf{A}$. Like the distribution-based attack (see Section~\ref{sec:distribution-attack-description}), we configure the frequency analysis scheme with the parameters $(u, r, t)$, and infer that the ciphertext cluster $\mathcal{C}_\mathbf{C}$ is similar to a plaintext cluster $\mathcal{C}_\mathbf{A}$, if they satisfy the following requirements:
  
\begin{itemize}[leftmargin=*]
    \item  The rank of $\mathcal{C}_\mathbf{C}$ is not larger than $u$.
    \item  The rank difference of $\mathcal{C}_\mathbf{C}$ and $\mathcal{C}_\mathbf{A}$ is not larger than $r$.  
    \item  The difference of $e(\mathcal{C}_\mathbf{C})$ and $e(\mathcal{C}_\mathbf{A})$ is the smallest and also not larger than $t$.
\end{itemize}

Then, for each pair $(\mathcal{C}_\mathbf{C}, \mathcal{C}_\mathbf{A})$ of similar clusters, we infer ciphertext-plaintext pairs in two levels. 
\begin{itemize}[leftmargin=*]
    \item {\bf Segment-level inference:}
        If $\mathcal{C}_\mathbf{C}$ and $\mathcal{C}_\mathbf{A}$ have the same number of logical chunks (i.e., ciphertexts or plaintexts), as well as an identical entropy, this implies that $\mathcal{C}_\mathbf{C}$ is exactly mapped from $\mathcal{C}_\mathbf{A}$ with a high probability. In this case, we operate attack on the coarse-grained {\em segment} level. Specifically, we first compute the entropies of each ciphertext segment $S_\mathbf{C}$ in $\mathcal{C}_\mathbf{C}$ and each plaintext segment $S_\mathbf{A}$ in $\mathcal{C}_\mathbf{A}$, based on the frequency distributions of their ciphertexts and plaintexts, respectively. 
         We infer that $S_\mathbf{C}$ is mapped from  $S_\mathbf{A}$, if the total numbers of logical chunks, as well as the entropies, of $S_\mathbf{C}$ and $S_\mathbf{A}$ are identical. Our evaluation shows that the segment-level inference contributes most of the correctly inferred contents in the
        clustering-based attack (see
        Section~\ref{sec:experiment-clustering}). It is also possible to further recover each plaintext in these inferred segments with additional adversarial knowledge (e.g., ordering). 
    \item {\bf Chunk-level inference:}
        If $\mathcal{C}_\mathbf{C}$ and $\mathcal{C}_\mathbf{A}$ have different numbers of logical chunks or entropies, we apply frequency analysis to operate attack on the fine-grained {\em chunk} level. Specifically, we sort all unique ciphertexts and plaintexts by their frequencies in $\mathcal{C}_\mathbf{C}$ and $\mathcal{C}_\mathbf{A}$, respectively, and infer ciphertext-plaintext pairs based on frequency ranks.  
        However, we find the chunk-level inference does not perform well in our experimental dataset. The possible reason is each cluster includes a large number of logical chunks, which degrades the effectiveness of  frequency analysis. Even so, we expect the chunk-level inference can recover more ciphertext-plaintext pairs in practice, especially when the number of logical chunks in some clusters is limited.   
\end{itemize}

\subsection{本章小结}

总而言之，基于聚类的攻击利用相似性，并在类似的聚类中启动频率分析以推断密文-明文对。 除$u$，$r$和$t$外，它还由参数$k$配置，该参数指定组合最近集群的上限距离。

尽管可能受到固定大小段的边界偏移的影响，但我们认为基于群集的攻击对VM磁盘映像是严重的。 具体地，平坦的VM映像文件在创建时被分配固定大小，并且在其生存期内不能改变这样的大小。 VM映像中的所有未使用区域最初填充零块，可以进一步重写该块以用于在图像中存储附加数据。 在Section \ ref {sec：experiment-clustering}中，我们研究了针对VM映像的基于群集的攻击的有效性。

To summarize, the clustering-based attack exploits similarity, and launches frequency analysis in similar clusters to infer ciphertext-plaintext pairs. In addition to  $u$, $r$ and $t$, it is configured by the parameter $k$, which specifies the upper bound distance in combining the closest clusters.   

Although possibly affected by the boundary shift of fixed-size segments, we argue that the clustering-based attack is severe against VM disk images. Specifically, a flat VM image file is allocated of a fixed size at the time it is created, and such size cannot be changed during its lifetime. All unused regions in a VM image are initially filled with  zero chunks, which can be further re-written for storing additional data in the image. In Section \ref{sec:experiment-clustering}, we examine the effectiveness of the clustering-based attack against VM images.


